use actix_web::{
    post,
    web::{Data, Json},
    HttpResponse,
};
use git_worker::GitWorker;
use serde::Serialize;
use sqlx::postgres::PgRow;
use sqlx::Row;

use crate::{
    extractors::AuthedUser,
    types::{dashboard::AppUpdateSubmission, ErrorResponse},
};

#[derive(Serialize)]
struct RepoAppFile {
    source: String,
    commit: String,
    version: String,
}

#[utoipa::path(
    path = "/dashboard/submit_app_update",
    request_body = AppUpdateSubmission,
)]
#[post("/submit_app_update")]
#[tracing::instrument(name = "Submitting app update", skip(user, pool, git_worker))]
pub async fn submit(
    user: AuthedUser,
    pool: Data<sqlx::postgres::PgPool>,
    git_worker: actix_web::web::Data<GitWorker>,
    submission: Json<AppUpdateSubmission>,
) -> HttpResponse {
    let mut con = match pool.acquire().await {
        Ok(c) => c,
        Err(_) => return HttpResponse::InternalServerError().finish(),
    };

    let repo_url: String = match sqlx::query(
        "SELECT repository
            FROM apps app
            INNER JOIN app_owners owner
            ON app.id = owner.app_id 
            WHERE owner.user_id = $1 AND app.id = $2 AND owner.verified_owner = TRUE",
    )
    .bind(user.uuid)
    .bind(submission.app_id.to_owned())
    .map(|r: PgRow| r.get("repository"))
    .fetch_one(&mut con)
    .await
    {
        Ok(r) => r,
        Err(_) => {
            return HttpResponse::BadRequest().json(ErrorResponse {
                error: "Unable to get repository URL for this app".into(),
                translation_key: crate::types::ErrorTranslationKey::AppSubmitUpdateCannotGetUrl,
            })
        }
    };

    let branch_name = format!(
        "appcenter-website/{}-{}",
        submission.app_id, submission.version_tag
    );
    let commit_message = format!("{} version {}", submission.app_id, submission.version_tag);

    let w = git_worker.clone();
    let branch = branch_name.to_owned();
    let message = commit_message.to_owned();

    match tokio::task::spawn_blocking(move || {
        let git_worker = w;
        let branch_name = branch;
        let commit_message = message;

        let commit_id =
            match git_worker.get_remote_commit_id_from_tag(&repo_url, &submission.version_tag) {
                Ok(id) => id,
                Err(_) => return false,
            };

        let info = RepoAppFile {
            source: repo_url,
            commit: commit_id,
            version: submission.version_tag.to_owned(),
        };

        if let Err(e) = git_worker.checkout_branch("main") {
            tracing::error!("Error checking out main branch: {}", e);
            return false;
        }

        if let Err(e) = git_worker.update_repo() {
            tracing::error!("Error updating git repo: {}", e);
            return false;
        }

        if let Err(e) = git_worker.create_branch(&branch_name) {
            tracing::error!("Error creating branch: {}", e);
            return false;
        }

        if let Err(e) = std::fs::write(
            git_worker
                .repo_path
                .join("applications")
                .join(format!("{}.json", submission.app_id)),
            serde_json::ser::to_string_pretty(&info).unwrap(),
        ) {
            tracing::error!("Error writing app info to repo: {}", e);
            if let Err(e) = git_worker.checkout_branch("main") {
                tracing::error!("Error changing local branch: {}", e);
            }

            if let Err(e) = git_worker.delete_local_branch(&branch_name) {
                tracing::error!("Error deleting local branch: {}", e);
            }

            return false;
        }

        if let Err(e) = git_worker.add_and_commit(&["applications"], &commit_message) {
            tracing::error!("Error committing app: {}", e);
            if let Err(e) = git_worker.checkout_branch("main") {
                tracing::error!("Error changing local branch: {}", e);
            }

            if let Err(e) = git_worker.delete_local_branch(&branch_name) {
                tracing::error!("Error deleting local branch: {}", e);
            }

            return false;
        }

        if let Err(e) = git_worker.push(&branch_name) {
            tracing::error!("Error pushing app: {}", e);
            return false;
        }

        true
    })
    .await
    {
        Ok(success) => {
            if !success {
                return HttpResponse::InternalServerError().finish();
            }
        }
        Err(_) => {
            return HttpResponse::InternalServerError().finish();
        }
    }

    if let Err(e) = git_worker
        .create_pull_request(
            commit_message,
            branch_name,
            "main".into(),
            "This pull request was automatically generated by the AppCenter website.".into(),
        )
        .await
    {
        tracing::error!("Error opening pull request: {}", e);
        return HttpResponse::InternalServerError().finish();
    }

    HttpResponse::Ok().finish()
}
